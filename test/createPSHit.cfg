process PROD  = {

        
    # NOTE : if one wants to run with the SiStripDigitizer,
    #        then mag.field in the OscarProducer should be
    #        turned ON; otherwise it gets (re)created by the
    #        SiStripDigitizer, which seems to corrupt at all 
    #        the edm::Event record
     

    # Step 1 : Event Generation

    # flat random E-gun, single muon
    # 
    # if you want another particle type, replace the PartID
    # (standard STDHEP numbering scheme)
    #
    # to run it along with CMS detector simulation
    # (OscarProducer) make sure to select QGSP physics
    # list, instead DummyPhysics ("Dummy" has only EM 
    # process and wont know to model interactions of
    # hadrons with matter)
    #

   service = MessageLogger
   {
      untracked vstring destinations = {"cout"}
      
      vstring categories = { "FwkJob" }

      PSet cout = { PSet default = { int32 limit = 0 }    # kill all messages in the log
                    PSet FwkJob  = { int32 limit = -1 } } # except *all* of FwkJob's	  
      
      untracked vstring fwkJobReports = {"FrameworkJobReport.xml"}
   }

   service = Timing {}


   service = RandomNumberGeneratorService
   {
      untracked uint32 sourceSeed = 135799753
      PSet moduleSeeds =
      {
         untracked uint32 VtxSmeared = 123456789
         untracked uint32 SimG4Object = 9876
      }
   }

  source = PoolSource {
     untracked vstring fileNames = {'file:/afs/cern.ch/cms/data/CMSSW/Validation/HcalHits/data/mc_pi+100_etaphi44.root'}
     untracked int32 maxEvents = -1
     untracked uint32 debugVebosity = 11
     untracked bool   debugFlag     = true
  }

  module VtxSmeared = VertexGenerator
   {
      string type = "IOMC/EventVertexGenerators/GaussianEventVertexGenerator"
      double MeanX = 0.
      double MeanY = 0.
      double MeanZ = 0.
      double SigmaX = 0.0
      double SigmaY = 0.0
      double SigmaZ = 0.0  // in mm (as in COBRA/OSCAR)
   }


 

   #Magnetic Field
 include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"



#Geometry
 include "Validation/HcalDigis/test/data/testGeometryXML.cfi"
		
		
   # Step 2 : CMS Detector Simulation

   # CMS Det.Simulation module (OscarProducer)
   #
   module SimG4Object = OscarProducer
   {
      bool NonBeamEvent = false
      untracked int32 RunNumber = 1001
      untracked int32 G4EventManagerVerbosity = 0
      untracked int32 G4StackManagerVerbosity = 0
      untracked int32 G4TrackingManagerVerbosity = 0
      # bool UseMagneticField = true
      bool UseMagneticField = false
      bool OverrideUserStackingAction = true
      bool StoreRndmSeeds = false
      bool RestoreRndmSeeds = false
      string PhysicsTablesDirectory = "PhysicsTables"
      bool StorePhysicsTables = false
      bool RestorePhysicsTables = false

      PSet MagneticField =
      {
         double delta = 1.
      }
      PSet Physics =
      {
         # NOTE : if you want EM Physics only,
         #        please select "SimG4Core/Physics/DummyPhysics" for type
         #        and turn ON DummyEMPhysics
         #
         string type = "SimG4Core/Physics/QGSP"
         bool DummyEMPhysics = false
         bool CutsPerRegion = true
         double DefaultCutValue = 1000.  # cuts in cm, i.e. 10m
         untracked int32 Verbosity = 0   # 1 will print cuts as they get set fdrom DD
                                         # 2 will do as 1 + will dump Geant4 table of cuts
      }
      PSet Generator =
      {
         bool ApplyPtCuts = true
         bool ApplyEtaCuts = true
         bool ApplyPhiCuts = false
         double MinPhiCut = 0.   # in degrees,
         double MaxPhiCut = 360. # internally converted to radians, (-pi,pi) range accounted for
         double MinEtaCut = -5.5
         double MaxEtaCut = 5.5
         double MinPtCut = 40.
         double MaxPtCut = 999999.
         untracked int32 Verbosity = 0
      }

      PSet RunAction = { string StopFile = "StopRun" }
      PSet EventAction =
      {
         bool CollapsePrimaryVertices = false
         string StopFile = "StopRun"
         untracked bool debug = false
      }

      PSet TrackingAction =
      {
         untracked bool DetailedTiming = false
      }
      PSet UtilityActions =
      {
               string type = "SimG4Core/UtilityAction/TrackingVerboseAction"
               untracked bool  DEBUG = false
               untracked bool  CheckForHighEtPhotons = false
               untracked int32 EventMin = 0
               untracked int32 EventMax = 0
               untracked int32 EventStep = 1
               untracked int32 TrackMin = 0
               untracked int32 TrackMax = 0
               untracked int32 TrackStep = 1
               untracked int32 VerboseLevel = 0 
      }

      PSet SteppingAction =
      {
         bool   KillBeamPipe = true
         double CriticalEnergyForVacuum = 2.0
         double CriticalDensity = 1.e-25
         untracked int32  Verbosity = 0
      }
	PSet CaloSD = 
	{
		double EminTrack = 1.0
		untracked int32  CheckHits = 25
		untracked bool   UseMap = true
		untracked int32  Verbosity = 0
		untracked bool   DetailedTiming = false
		bool   DetailedTiming = false
	}
	PSet ECalSD = 
	{
		bool   UseBirkLaw = false
		double BirkC1 = 0.013
		double BirkC2 = 9.6e-6
	}
	PSet HCalSD = 
	{
		bool   UseBirkLaw = false
		double BirkC1 = 0.013
		double BirkC2 = 9.6e-6
		bool   UseShowerLibrary = true
		bool   TestNumberingScheme = false
	}
	PSet CaloTrkProcessing = 
	{
		int32 Verbosity = 0
		bool   TestBeam  = false
		double EminTrack = 0.01
	}                     
	PSet HFShower =    
	{
		double ProbMax   = 0.7268
		double CFibre    = 0.50
	}
	PSet HFShowerLibrary = 
	{
		FileInPath FileName = "SimG4CMS/Calo/data/hfshowerlibrary_lhep.root"
		string TreeEMID  = "h3"
		string TreeHadID = "h8"
	}
	PSet HFCherenkov = 
	{
		double RefIndex        = 1.459
		double Lambda1         = 280.0
		double Lambda2         = 700.0
		double Aperture        = 0.33
		double ApertureTrapped = 0.22
		double Gain            = 0.33
		bool   CheckSurvive    = false
	}
   }  # end of OscarProducer's PSet's/block


   # Step 3 : Digitization of the simulated hits
   #

   # Step 3a : Digitization of the Tracker
   #

   # required for Pixel and SiStrip Digitizers
   #
   es_module = TrackerDigiGeometryESModule {}

   # Pixel's digitization
   #
   include "SimTracker/SiPixelDigitizer/data/PixelDigi.cfi"

   # SiStrip's digitization
   #
   include "SimTracker/SiStripDigitizer/data/SiStripDigi.cfi"

   # Step 3b : Digitization of Ecal and Hcal

   # required for Ecal and Hcal Digitizers
   # NOTE : Both Ecal and Hcal geometries need to be present,
   #        even if only one digitizers is to run
   #
   es_module = EcalPreshowerGeometryEP {}
   es_module = EcalBarrelGeometryEP {}
   es_module = EcalEndcapGeometryEP {}
   es_module = HcalHardcodeGeometryEP {}
   es_module = CaloTowerHardcodeGeometryEP {}
   es_module = CaloGeometryBuilder {}

   es_module = HcalDbProducer {}
   es_source es_hardcode = HcalHardcodeCalibrations
   {
      untracked vstring toGet =
      {
         "Pedestals", "PedestalWidths",
         "Gains", "GainWidths",
         "QIEShape", "QIEData",
         "ChannelQuality", "ElectronicsMap"
      }
   }

   include "SimCalorimetry/EcalSimProducers/data/ecaldigi.cfi"
   
   include "SimCalorimetry/HcalSimProducers/data/hcaldigi.cfi"




   # Step 4 : Output module
   #
   module o1 = PoolOutputModule 
   { 
      untracked string fileName = "simhits_nue.root" 
   }

   path p1 = { SimG4Object }
   endpath outpath = { o1 }
		
}		
